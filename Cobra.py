import random
import socket
from Hmac import *
from helpFunction import * 
from hash import *

# Representing the golden ratio on 32 bits, and r the number of permutations
phi = 0b00111111110011110001101110111101
r =32

#Tables of permutations for Serpent (IPTable - Initial Permutation and FPTable - Final Permutation)
IPTable = [
    0, 32, 64, 96, 1, 33, 65, 97, 2, 34, 66, 98, 3, 35, 67, 99,
    4, 36, 68, 100, 5, 37, 69, 101, 6, 38, 70, 102, 7, 39, 71, 103,
    8, 40, 72, 104, 9, 41, 73, 105, 10, 42, 74, 106, 11, 43, 75, 107,
    12, 44, 76, 108, 13, 45, 77, 109, 14, 46, 78, 110, 15, 47, 79, 111,
    16, 48, 80, 112, 17, 49, 81, 113, 18, 50, 82, 114, 19, 51, 83, 115,
    20, 52, 84, 116, 21, 53, 85, 117, 22, 54, 86, 118, 23, 55, 87, 119,
    24, 56, 88, 120, 25, 57, 89, 121, 26, 58, 90, 122, 27, 59, 91, 123,
    28, 60, 92, 124, 29, 61, 93, 125, 30, 62, 94, 126, 31, 63, 95, 127,
    ]

FPTable = [
    0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60,
    64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124,
    1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49, 53, 57, 61,
    65, 69, 73, 77, 81, 85, 89, 93, 97, 101, 105, 109, 113, 117, 121, 125,
    2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, 54, 58, 62,
    66, 70, 74, 78, 82, 86, 90, 94, 98, 102, 106, 110, 114, 118, 122, 126,
    3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63,
    67, 71, 75, 79, 83, 87, 91, 95, 99, 103, 107, 111, 115, 119, 123, 127,
 ]

# S-Box table for Serpent
SBoxDecimalTable = [
	[ 3, 8,15, 1,10, 6, 5,11,14,13, 4, 2, 7, 0, 9,12 ], # S0
	[15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 ], # S1
	[ 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 ], # S2
	[ 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 ], # S3
	[ 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 ], # S4
	[15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 ], # S5
	[ 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 ], # S6
	[ 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 ], # S7
    ] 


def applyPermutation(permutationTable, input):
    """
    Apply the permutation in 'permutationTable' to the 128-bit bitstring
    'input' and returns a 128-bit bitstring as the result.
    """
    if len(input) != len(permutationTable):
        raise ValueError("The input size (%d) is not the same as the size of the permutation table (%d)"% (len(input), len(permutationTable)))
    result = ""
    for i in range(len(permutationTable)):
        result = result + input[permutationTable[i]]
    return result


SBoxBitstring = []
SBoxBitstringInverse = []

for line in SBoxDecimalTable:
    dict = {}
    inverseDict = {}
    for i in range(len(line)):
        index = format(i, '04b')
        value = format(line[i], '04b')
        dict[index] = value
        inverseDict[value] = index
    SBoxBitstring.append(dict)
    SBoxBitstringInverse.append(inverseDict)


def S(box, input):
    """
    Apply S-box number 'box' to 4-bit bitstring 'input' and return a 4-bit bitstring as the result.
    """
    return SBoxBitstring[box%8][input]


def SInverse(box, output):
    """
    Apply S-box number 'box' in reverse to 4-bit bitstring 'output' and
    returns a 4-bit bitstring (the input) as the result.
    """
    return SBoxBitstringInverse[box%8][output]


def initializeKey (sessionKey):
    """
    Initialize the key expansion to obtain a 256-bit key from the session key.
    return a list of 8 32-bit blocks of the session key.
    """
    K=[]
    while len(sessionKey)<256:
        sessionKey.append(0)
    for i in range(8):
        K.append(sessionKey[i*32:32+i*32])
    return K


def keyExpansion(K):
    """
    This function iterates the key expansion, starting from the 8 subblocks of the session key.
    It generates an array of 132 subkeys by applying a recurrence function.
    """
    w=[]
    for i in range (8):
        w.append(int(K[i], 2))
    for i in range (8,132):
        w.append(rol(w[i-8]^w[i-5]^w[i-3]^w[i-1]^phi^i, 11, 32))
    for i in range (len(w)):
        w[i] = format(w[i], '032b') 
    return w


def SBoxTransform (w):
    """
    This function applies the S-box transformation to the 132 subkeys generated by the key expansion.
    It returns two lists of 33 128-bit bitstrings, which are the 132 subkeys transformed by the S-boxes.
    """
    k = {}
    for i in range(r+1):
        whichSBox = (r + 3 - i) % r
        k[0+4*i] = ""
        k[1+4*i] = ""
        k[2+4*i] = ""
        k[3+4*i] = ""
        for j in range(32): 
            input = w[0+4*i][j] + w[1+4*i][j] + w[2+4*i][j] + w[3+4*i][j]
            output = S(whichSBox, input)
            for l in range(4):
                k[l+4*i] = k[l+4*i] + output[l]
    K = []
    for i in range(33):
        K.append(k[4*i] + k[4*i+1] + k[4*i+2] + k[4*i+3])
    # According to the algorithm documentation, we apply the initial permutation to place the elements of K[i] in the correct column
    KHat = []
    for i in range(33):
        KHat.append(applyPermutation(IPTable,K[i]))
    return KHat, K


def SBitslice(box, words):
    """
    Takes 'words', a list of 4 32-bit bitstrings, least significant word first.
    Returns a similar list of 4 32-bit bitstrings obtained as follows.
    For each bit from 0 to 31, applying S-box number 'box'
    to the input bits coming from their current position in each
    item in 'words'; and putting the 4 output bits in the corresponding positions
    in the output words.
    """

    result = ["", "", "", ""]
    for i in range(32):
        quad = S(box, words[0][i] + words[1][i] + words[2][i] + words[3][i])
        for j in range(4):
            result[j] = result[j] + quad[j]
    return result


def SBitsliceInverse(box, words):
    """
    This function takes 'words', a list of 4 32-bit bitstrings, least significant word
    first. Returns a similar list of 4 32-bit bitstrings obtained as
    follows. 
    For each bit position from 0 to 31, apply S-box number 'box'
    in reverse to the 4 output bits coming from the current position in
    each of the items in the supplied 'words'; and put the 4 input bits in
    the corresponding positions in the returned words.
    """

    result = ["", "", "", ""]
    for i in range(32): 
        quad = SInverse(
            box, words[0][i] + words[1][i] + words[2][i] + words[3][i])
        for j in range(4):
            result[j] = result[j] + quad[j]
    return result


def F(Ki, R):
    """
    This function applies the F function to the 64-bit bitstring 'R' using the 128-bit bitstring 'Ki'.
    It returns a 64-bit bitstring as the result.
    """
    Ri = octoSplit(R)
    for i in range (len(Ri)):
        Ri[i] = reverseBits(int(Ri[i], 2), 8)
        Ri[i]= pow(Ri[i]+1, -1, 257) -1
        Ri[i] = format(Ri[i], '08b')
    permTable = [56, 38, 60, 33, 20, 9, 36, 58, 26, 10, 49, 61, 14, 8, 24, 62, 52, 12, 43, 59, 54, 18, 44, 11, 57, 31, 27, 53, 34, 39, 13, 51, 29, 28, 0, 48, 6, 55, 17, 35, 2, 16, 32, 37, 1, 47, 4, 15, 41, 42, 45, 63, 3, 25, 5, 21, 22, 46, 30, 50, 40, 7, 19, 23]
    Ri = applyPermutation(permTable, octoJoin(Ri))
    Ri = octoSplit(Ri)
    for i in range (len(Ri)):
        random.seed(int(Ri[i], 2))
        Ri[i] = format(random.getrandbits(8), '08b')
    derivedKey = SHA3_256(int(Ki, 2).to_bytes(16, 'big')).hexdigest()
    derivedKey = format(int(derivedKey, 16), '0256b')
    Ri = octoJoin(Ri)
    result = ''.join(str(int(R[i]) ^ int(derivedKey[i])) for i in range(64))
    return result


def laFeistelDeRere(Si, Ki):
    """
    This function applies the Feistel network to the 128-bit bitstring 'Si' using the 128-bit bitstring 'Ki'.
    It returns a 128-bit bitstring as the result.
    """
    L, R = biSplit(Si)
    for i in range (3):
        Li = R
        Ri = int(L, 2) ^ int(F(Ki, R), 2)
        L = Li
        R = format(Ri, '064b')
    return L+R


def laFeistelDeRereInverse(Si, Ki):
    """
    This function applies the Feistel network in reverse to the 128-bit bitstring 'Si' using the 128-bit bitstring 'Ki'.
    """
    L, R = biSplit(Si)
    for i in range (3):
        Ri = L
        Li = int(R, 2) ^ int(F(Ki, L), 2)
        R = Ri
        L = format(Li, '064b')
    return L+R
    

def LTBitslice(X):
    """
    This function applies the equations-based version of the linear transformation
    to 'X', a list of 4 32-bit bitstrings, least significant bitstring first,
    and returns another list of 4 32-bit bitstrings as the result.
    """
    X[0] = rol(int(X[0], 2), 13, 32)
    X[2] = rol(int(X[2], 2), 3, 32)
    X[1] = int(X[1], 2) ^ X[0] ^ X[2]
    X[3] = int(X[3], 2) ^ X[2] ^ leftShift(X[0], 3)
    X[1] = rol(X[1], 1, 32)
    X[3] = rol(X[3], 7, 32)
    X[0] = X[0] ^ X[1] ^ X[3]
    X[2] = X[2] ^ X[3] ^ leftShift(X[1], 7)
    X[0] = rol(X[0], 5, 32)
    X[2] = rol(X[2], 22, 32)
    X[0] = format(X[0], '032b')
    X[1] = format(X[1], '032b')
    X[2] = format(X[2], '032b')
    X[3] = format(X[3], '032b')
    return X


def LTBitsliceInverse(X):
    """
    This function applies, in reverse, the equations-based version of the linear
    transformation to 'X', a list of 4 32-bit bitstrings, least significant
    bitstring first, and returns another list of 4 32-bit bitstrings as the
    result.
    """
    X[2] = ror(int(X[2], 2), 22, 32)
    X[0] = ror(int(X[0], 2), 5, 32)
    X[2] = X[2] ^ int(X[3], 2) ^ leftShift(int(X[1], 2), 7)
    X[0] = X[0] ^ int(X[1], 2) ^ int(X[3], 2)
    X[3] = ror(int(X[3], 2), 7, 32)
    X[1] = ror(int(X[1], 2), 1, 32)
    X[3] = X[3] ^ X[2] ^ leftShift(X[0], 3)
    X[1] = X[1] ^ X[0] ^ X[2]
    X[2] = ror(X[2], 3, 32)
    X[0] = ror(X[0], 13, 32)
    X[0] = format(X[0], '032b')
    X[1] = format(X[1], '032b')
    X[2] = format(X[2], '032b')
    X[3] = format(X[3], '032b')
    return X


def round(i, Bi, Ki):
    """
    This function applies the round 'i' of the Serpent algorithm to the 128-bit bitstring 'Bi' using the 128-bit bitstring 'Ki'.
    It returns a 128-bit bitstring as the result.
    """
    xored = int(Bi, 2) ^ int(Ki, 2)
    xored = format(xored, '0128b')
    Si = SBitslice(i, quadSplit(xored))
    Si = quadJoin(Si)
    LFDR = laFeistelDeRere(Si, Ki)
    if i == r-1:
        biPlus1 = int(LFDR, 2) ^ int(Ki[r], 2)
        biPlus1 = format(biPlus1, '0128b')
    else:
        biPlus1 = quadJoin(LTBitslice(quadSplit(LFDR)))
    return biPlus1


def invRound(i, Biplus1, Ki):
    """
    This function applies the inverse of the round 'i' of the Serpent algorithm to the 128-bit bitstring 'Biplus1' using the 128-bit bitstring 'Ki'.
    """
    if i == r-1:
        Si = int(Biplus1, 2) ^ int(Ki[r], 2)
        Si = format(Si, '0128b')
    else:
        Si = quadJoin(LTBitsliceInverse(quadSplit(Biplus1)))
    LFDRInverse = laFeistelDeRereInverse(Si, Ki)
    xoredInverse = SBitsliceInverse(i, quadSplit(LFDRInverse))
    xoredInverse = quadJoin(xoredInverse)
    Bi = int(xoredInverse, 2) ^ int(Ki, 2)
    Bi = format(Bi, '0128b')
    return Bi    


def encrypt(plainText, key):
    """
    This function encrypts the plaintext 'plainText' using the key 'key' and returns the ciphertext.
    """
    bitText = toBitstring(plainText)
    genKey = initializeKey(key)
    w = keyExpansion (genKey)
    KHat, K = SBoxTransform(w)
    B=applyPermutation(IPTable, bitText)
    for i in range(r):
        B = round(i, B, KHat[i])
    cipherText = applyPermutation(FPTable, B)
    return cipherText


def decrypt(cipherText, key):
    """
    This function decrypts the ciphertext 'cipherText' using the key 'key' and returns the plaintext.
    """
    genKey=initializeKey(key)
    w = keyExpansion (genKey)
    KHat, K = SBoxTransform(w)
    B = applyPermutation(IPTable, cipherText)
    for i in range (r-1, -1, -1):
        B = invRound(i, B, KHat[i])
    plainText = applyPermutation(FPTable, B)
    plainText = toText(plainText)
    return plainText


def sendMessage(key, message, socket):
    """
    This function sends a message to the socket 'socket' using
    the key 'key'.
    """
    print(message)
    messageBlocks = textParser(message)
    messageHmac = hmac(key, message)
    print("HMAC of the message: ", messageHmac)
    cipherLen = encrypt(str(len(messageBlocks)), key)
    socket.send(str(cipherLen).encode())
    cipherText = []

    for i in range(len(messageBlocks)):
        cipherBlock = encrypt(messageBlocks[i], key)
        cipherText.append(cipherBlock)
        socket.send(str(cipherBlock).encode())
        
    print("Cipher text: ", cipherText)
    socket.send(messageHmac.encode())
    

def receiveMessage(key, socket):
    """
    This function receives a message from the socket.
    """
    receivedData = socket.recv(128)
    plainNbBlocks = decrypt(receivedData.decode(), key)
    nbBlocks = int(plainNbBlocks)
    message = ""

    for i in range(nbBlocks):
        receivedData = socket.recv(128)
        plainText = decrypt(receivedData.decode(), key)
        message += plainText

    receivedData = socket.recv(64)
    receivedHmac = receivedData.decode()
    messageHmac = hmac(key, message)
    print(messageHmac)

    if messageHmac == receivedHmac :
        print("Hmac verified")
    else:
        print("Warning, different Hmac")
    return message


def cobraTest(key):
    """
    This function tests the Serpent algorithm by encrypting and decrypting a message.
    """
    testString = input("Enter the text to encrypt: ")
    print("Text to encrypt: ", testString)
    cipherText = encrypt(testString, key)
    print("Encrypted text: ", cipherText)
    plainText = decrypt(cipherText, key)
    print("Decrypted text: ", plainText)

